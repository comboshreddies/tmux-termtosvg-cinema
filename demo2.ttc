export PS1="\[\e[01;32m\]tks $\[\e[00m\] "
export PATH="$PATH:${HOME}/bin"
termtosvg
export PS1="\[\e[01;32m\]tks $\[\e[00m\] "

banner " " " " "tks :" "verify" "k8s setup" | lolcat 

# verifying that we have pods to work on
kubectl -n test-run get pod --show-labels
kubectl -n test-run get pod -l app=nginx

banner " " " " "tks :" "oneliner" | lolcat 

# one-liners are designed to be short, but they might not be easily readable. Power
# of one-liners come with prepared scripts and shortcuts, but will start with empty state
# (so no ~/.tks/sequences.json for a start, we will add those later)
# here is simple one liner that executes env for each pod in nginx container
# pods are selected with -l app=nginx 

kubectl tks -n test-run start -l app=nginx  "_ exec {{pod}} -c nginx -- env"  

# start command will try to find a script within ~/.tks/sequences.json
# as there is no script named "_ exec {{pod}} -c nginx -- env", it 
# will assume argument is not a script name but one-liner 
# _ shortcut will run kubectl with same kubectl switches (--context, -n, --kubeconfig)
# as tks was executed, so in this case _ will be replaced with
# "kubectl -n test-run"
# for each pod new tmux window will be created, and script
# kubectl -n test-run exec {{pod}} -c nginx -- env 
# will be executed for each pod, replacing {{pod}} with specific pod name
# new tmux session OneLiner--test-run is created with base window

# check available tmux sessions
tmux ls
# attach to tmux so we can see what has been executed
tmux attach -t OneLiner--test-run
#C ssh gdt "tmux next-window -t OneLiner--test-run"

#C tmux send-keys -t 0 "# next screen"

#C ssh gdt "tmux next-window -t OneLiner--test-run "

#C ssh gdt tmux next-window -t OneLiner--test-run

#C ssh gdt tmux next-window -t OneLiner--test-run 

#C tmux send-keys -t 0 "# detach from tmux"

#C ssh gdt "tmux detach-client -s OneLiner--test-run"

# note: tmux is up and running after script execution



banner " " " " "tks :" "tmux left" "running" | lolcat

# next run of one-liner will try to open same session name and will fail with error,
# as one-liners might have overlapping session-names and will fail
kubectl tks -n test-run start -l app=nginx  "_ exec {{pod}} -c nginx -- env"
# ^^ last line shows error   
# let us check tmux session, you can easily do tmux kill-session -t <session name>
tmux ls
# session is composed of a context,namespace, and script name, and for one-liners
# script name is "OneLiner" and always the same
# later you will see how to terminate session within script/one-liner
# you might have something valuable within tmux and we do not want to
# delete previous session as default behaviour

banner " " " " "tks : -T" "tmux session" "restart" | lolcat

# adding -T option will instruct tks to kill previous session before starting new one
kubectl tks -n test-run start -l app=nginx  "_ exec -t {{k8s_pod}} -c nginx -- env" -T

# if you want to name your tmux session use start with -S <your session name>


banner " " " " "tks : -d" "tmux" "dry run" | lolcat

# if you want to show what will be executed and not to execute for real there is -d flag
kubectl tks -n test-run start -l app=nginx  "_ exec -t {{k8s_pod}} -c nginx -- env" -T -d

# tks will render all known template variables (shortcuts, internal _, controls, kubernetes)


banner " " " " "tks :" "multiple" "commands" | lolcat

# within a one-liner you might want to run more than one command, so for one-liners
# with ; character you can use to separate multiple commands
# ; separator will not work in prepared scripts, ie this works only in one-liners
#
# here as a first step we will execute env on a pod, then as a second step we will echo podname
kubectl tks -n test-run start -l app=nginx  "_ exec {{pod}} -c nginx -- env ; echo {{pod}}" -T

# attach to tmux so we can see what has been executed
tmux attach -t OneLiner--test-run
#C ssh gdt "tmux next-window -t OneLiner--test-run"

#C tmux send-keys -t 0 "# next screen"

#C ssh gdt tmux next-window -t OneLiner--test-run

#C ssh gdt tmux next-window -t OneLiner--test-run

#C ssh gdt tmux next-window -t OneLiner--test-run 

#C tmux send-keys -t 0 "# detach from tmux"

#C ssh gdt "tmux detach-client -s OneLiner--test-run"


banner " " " " "tks :" "predef" "control" | lolcat

# to be able to operate within tmux windows/panes there are some specific controls
# here is how you can check what controls are available
tks list control
# with OP_COMMENT you can make a comment that will be printed and rendered
kubectl tks -n test-run start -l app=nginx  "_ exec {{pod}} -c nginx -- env ;{{OP_COMMENT}} doing env on pod {{pod}}" -T

# OP_TERMINATE control operation instructs tks to terminate tmux session as last step of execution
kubectl tks -n test-run start -l app=nginx  "_ exec {{pod}} -c nginx -- env ;{{OP_TERMINATE}}" -T

# check tmux sessions
tmux ls

# OP_ATTACH control operation instructs tks to attach tmux session, so you do not need to run tmux attach manuall
kubectl tks -n test-run start -l app=nginx  "_ exec {{pod}} -c nginx -- env ;{{OP_ATTACH}}" -T

#C ssh gdt "tmux next-window -t OneLiner--test-run"

#C tmux send-keys -t 0 "# next screen"

#C ssh gdt tmux next-window -t OneLiner--test-run

#C ssh gdt tmux next-window -t OneLiner--test-run

#C ssh gdt tmux next-window -t OneLiner--test-run 

#C tmux send-keys -t 0 "# detach from tmux"

#C ssh gdt "tmux detach-client -s OneLiner--test-run"

# tmux should be now detached but live
tmux ls

# there are also short versions, so {{_T}} for terminate and {{_C}} for comment, and {{_A}} for attach
# in one-liners each {{OP_ command must come after ; character, otherwise will not work. all commands 
# start with beginning of line. For more info you can check scripts within sequence.json .


banner " " " " "tks : -s" "sync" "async" | lolcat

# there are two ways of executing scripts, default is async
# in async each script per pod will run separately at their own pace
# in async mode some pod-scripts might have completed while others are still progressing
# in sync mode each step is executed on all pods, prompt is waited then next step is executed 
# 
# in sync mode all pod should execute first command , then second can be executed 
tks -n test-run start -f sequences.json  -l app=nginx "echo ABCD {{pod}}; echo XYZW {{pod}}" -T -d -s
# in async mode script will run on each pod, step by step, independently from other pods
# so dry run in default mode will show steps oriented by pod (not by script step)
tks -n test-run start -f sequences.json  -l app=nginx "echo ABCD {{pod}}; echo XYZW {{pod}}" -T -d
# even if dry run in async mode will print pod by pod, all pods will run in same time
# and might end in different times
#
# async mode is practical if you have script execution that might fail
# for example I have run a script on 100 pods, 5 of them failed (had high load) but I have got
# results from 95% of platform, and then I attach to tmux and check failed windows


banner " " " " "tks :" "kubectl" "variables" | lolcat

# tks has list of kubectl specific template variables
# template variables are enclosed by {{ and }}
# you can list what kubectl templated variables are
kubectl tks list kctl
     
# for readability there are long {{k8s_ template variables
kubectl tks -n test-run start -l app=nginx  "kubectl -n {{k8s_namespace}} exec -t {{k8s_pod}} -c nginx -- env" -T

# for one-liners there are short {{nsp}}, {{pod}} , {{ctx}} , {{cnf}} template variables
kubectl tks -n test-run start -l app=nginx  "kubectl -n {{nsp}} exec -t {{pod}} -c nginx -- env" -T

# it is always simpler to specify _ (internal shortcut) then whole kubectl section
kubectl tks -n test-run start -l app=nginx  "_ exec {{pod}} -c nginx -- env ; echo {{pod}}" -T -d

# as _ is adoptable to different ways of running kubectl
kubectl tks --context minikube -n test-run start -l app=nginx  "_ exec {{pod}} -c nginx -- env ; echo {{pod}}" -T -d

# _ works in a flexible way , if you provide context or config file _ will show them, if not they will not be
# used, ie script will use same key parameters as your kubectl did



banner " " " " "tks :" "sequence" "json" | lolcat

# first copy sequences.json to expected place
# if you do not want to have default or you want to use other sequence.json
# file then you can use -f switch to specify different sequence.json
mkdir -p ~/.tks
cp sequences.json ~/.tks

# here is a list of scripts that are being loaded from sequence.json file
tks list scripts

# note: kubectl-tks can be copied/linked to tks so 
# you can call kubectl tks or just tks
#

# we can inspect sequences.json with jq, there are 3 sections
cat ~/.tks/sequences.json | jq ".|keys" 

# here we can see env script within scripts
cat ~/.tks/sequences.json| jq .scripts.env

# here is env-nginx-simple script
cat ~/.tks/sequences.json| jq ".scripts.\"env-nginx-simple\""

# tks info can show you details of a script, you don not have to jq
tks info env-nginx-simple

# we can ask for rendering/expanding of a script
tks info env-nginx-simple -x

# now we se how shortcuts and scripts resolve


banner " " " " "tks :" "scripts" "start" | lolcat

# here is a list of scripts
tks list scripts

# here we can extract script from json file
cat ~/.tks/sequences.json| jq ".scripts.\"env-nginx-simple\""

# here is how to do same with tks info
tks info env-nginx-simple

# with -x you can render shortcuts within a script
tks info env-nginx-simple -x

# k8s_ template variables will stay unredered, as they are available runtime
# so we can check with -d
kubectl tks -n test-run start env-nginx-simple -l app=nginx -T -d

# now we can run script
kubectl tks -n test-run start env-nginx-simple -l app=nginx -T

# check what is in our present working directory
ls -l

# and what is in fetched env file
cat nginx-sample1-b88fdd4c5-cdcn6.env 

# as a homework you coud add "{{OP_FINALLY}} tar czvf env-nginx-simple.tgz nginx-*env"
# archive as last execution command that is run on local host and remove env files
# all content after {{OP_FINALLY}} is passed to shell execution so you can do both tar and rm


banner " " " " "tks :" "list" "overview" | lolcat 

# show tks available list options
tks list

# list kubectl template variables - internally implemented
tks list kctl

# list control - controls are internally implemented
tks list control

# list scripts
tks list scripts

# list shortcuts  - will cover them soon
tks list shortcuts

#list podConverter - will cover them soon
tks list podConverter


banner " " " " "tks : " "shortcuts"  | lolcat 

# list of shortcuts
tks list shortcuts

# shortcuts are {{ and }} enclosed shortcut items within sequence.json .sortcuts section
# left part is shortcut shortcut, right part is expanded version
# one shortcut can contain reference for other shortcut, 
#
# if you want to shoot your self you can specify them recursively, (like A shortcut references
# B shortcut, B shortcut references A shortcut, but there is a limited set of shortcuts 
# resolution steps, so they won't run forever
# as example if you use {{ECB}} in your script it will be replaced with "{{EC}} /bin/bash -c" in
# first resolution/expansion step, then "{{EC}} /bin/bash -c" will be replaced with 
# "_ exec {{pod}} -c {{p2c}} -- /bin/bash -c", and then _ will be runtime replaced with
# some kubectl command (ECB is named because it Execute Container Bash)
# so for you can try this one-liner that is compressed yet expressive:
kubectl tks -n test-run start -l app=nginx "{{ECB}} date" -T -d

# shortcuts are powerful way of expressing most repetative tasks, only imagination is your limit


banner " " " " tks "pod" "Converter" | lolcat

# check podConverter section p2c item
cat ~/.tks/sequences.json| jq ".podConverter.p2c"

# or via tks
kubectl tks list podConverter

# pod convertes are used for mapping pod name to some other value
# podConverter section makes your script/shortcuts work on various kinds of pods/containers
# they use regular expression on right side and map to left side
# for example if you have two pods, one having /bin/sh and other /bin/bash
# you can check p2sh podConverter item, it will map nginx to /bin/bash and
# any other to /bin/sh, or if those two pods have different name of a container
# you want to exec to, you should check p2c section
# I have used p2cLogs when I do have separate logging container then main execution pod
# so I can choose only those container names that have logs

# by checking example script tcptump-all you can see how podConverter are being used
tks info tcpdump-all
# yet no podConverter will be replaced with -x option
# as podConverter depend on pod name, and pod name is avalable only runtime
# (so use start and -d for dry run)



banner " " " " "tks : info" "and" "version" | lolcat 

# checking content of env-nginx-simple script
tks info env-nginx-simple

# checking rendered content of env-nginx-simple script
# by adding -x flag 
tks info env-nginx-simple -x

# note: only shortcuts will be rendered as k8s/kctl variables are runtime
# to verify runtime template variable rendering do start with -d/dryrun option

# also you can check tks version
tks version

banner " " " " tks "advanced" " " | lolcat

# example of a more complex script tcpdump-all
tks info tcpdump-all

# tcpdump-all tcpdump-all script will run on debian like pods
# * do apt update and apt install of a tcpdump
# * do time and capture packets limited tcpdump on each pod
# * archive pcap capture files
# * copy files to tks running host
# * terminate tmux session
#
# running of tcpdump-all script
kubectl tks -n test-run start tcpdump-all -l app=nginx
sleep 12 # as tcpdump runs for 10 sec
# check what files are being copied to localhost
ls *.pcap.gz
# real beauty of running this example is when you run this one on few hundred pods 
# :)


# another more complex script
tks info remote-exec
# we instruct tks not to wait for prompt because on exec we will
# get prompt from pod/container, not a local one tks will usually wait for
# then we instruct tks to read new prompt, so tks loads pod/container prompt
# as expected result on next command, then we execute few sleeps on pod/container
# then we exit and we request again that tks do not expect saved prompt, but to skip
# and load new one, the one from local host
#
# running of remote-exec
kubectl tks -n test-run start remote-exec -l app-nginx
# you can tmux attach to check
#
#
# now being able to adjust different prompts I have used same tks not just for kubectl
# for for custom scripts that can jump to node, find pod of exact container and 
# nsenter to container I was interested to inspect, strace, gdb or whatever
#
# if you do not want to have shortcuts and scripts in sequence.json or some other sequence
# file you can always create custom script and run 
# kubectl tks -n test-run start "./custom.sh {{pod}} {{nsp}} {{ctx}} {{cnf}}"
# use tks just as an iterator or generator and do whatever you can imagine
#
# the end   


banner " " " " tks "the end" " " | lolcat

